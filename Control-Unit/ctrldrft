module ctrl_unit (
    input  [7:0] instruction,   // 8-bit instruction
    output reg [3:0] alu_op,    // ALU operation
    output reg reg_write,       // enable register write
    output reg mem_read,        // memory read enable
    output reg mem_write,       // memory write enable
    output reg pc_write,        // program counter write enable
    output reg alu_src,         // 0 = reg, 1 = immediate
    output reg [1:0] reg_dst,   // destination register
    output reg [1:0] reg_src    // source register
);

    wire [3:0] opcode = instruction[7:4];
    wire [1:0] rd     = instruction[3:2];
    wire [1:0] rs     = instruction[1:0];

    always @(*) begin
        // default values
        alu_op     = 4'b0000;
        reg_write  = 0;
        mem_read   = 0;
        mem_write  = 0;
        pc_write   = 0;
        alu_src    = 0;
        reg_dst    = rd;
        reg_src    = rs;

        case (opcode)
            4'b0000: begin // NOP
                // do nothing
            end
            4'b0001: begin // ADD
                alu_op    = 4'b0000; // ADD in ALU
                reg_write = 1;
            end
            4'b0010: begin // SUB
                alu_op    = 4'b0001;
                reg_write = 1;
            end
            4'b0011: begin // AND
                alu_op    = 4'b0010;
                reg_write = 1;
            end
            4'b0100: begin // OR
                alu_op    = 4'b0011;
                reg_write = 1;
            end
            4'b0101: begin // MOV
                alu_op    = 4'b1010; // just pass value
                reg_write = 1;
            end
            4'b0110: begin // LOAD
                mem_read  = 1;
                reg_write = 1;
            end
            4'b0111: begin // STORE
                mem_write = 1;
            end
            4'b1000: begin // JMP
                pc_write  = 1;
            end
            default: begin
                // unknown instruction
            end
        endcase
    end
endmodule
